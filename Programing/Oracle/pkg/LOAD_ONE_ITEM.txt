CREATE OR REPLACE PACKAGE BODY EDW0.PKG_ETL_UNL_FILES
AS
   g_extTableName varchar2(64);
   g_fileType         varchar2(64);
   g_fileName         varchar2(64);
   g_fileID         number;
   g_insertStmt    clob;
   g_extTableSchema varchar2(64) default 'ODI_BASELOAD'; 
   PROCEDURE LOAD_ONE_ITEM (p_loadItemID VARCHAR2)
   AS
   BEGIN
        SELECT file_type INTO g_fileType
          FROM dwc_input_file
               WHERE load_item_cd = p_loadItemID
              GROUP BY file_type;
      
        DBMS_OUTPUT.PUT_LINE('-start load item ' || p_loadItemID);

      g_extTableName := upper('ext$_' || g_fileType || '_' || p_loadItemID);
      
      CREATE_EXT_TAB;
      BUILD_INSERT_STMT;
      
            
        
      
      FOR file_row 
          IN (SELECT file_name, id
               FROM dwc_input_file
              WHERE load_item_cd = p_loadItemID AND status = 'READY2LOAD' order by id)
      LOOP
          g_fileId := file_row.id;
         g_fileName := file_row.file_name;
         DBMS_OUTPUT.PUT_LINE('filename=' || g_fileName || ' type=' || g_fileType);
       
         DBMS_OUTPUT.PUT_LINE('changing status to ALTER_EXT');
         UPDATE_STATUS ('ALTER_EXT', NULL, NULL);
            
         DBMS_OUTPUT.PUT_LINE('altering table');
         ALTER_EXT_TAB;  
          
         DBMS_OUTPUT.PUT_LINE('changing status to LOADING');
         UPDATE_STATUS ('LOADING', NULL, NULL);
                   
         DBMS_OUTPUT.PUT_LINE('start load from external table');
         LOAD_FROM_EXT_TAB;
         
      END LOOP;
        DBMS_OUTPUT.PUT_LINE('-end load item ' || p_loadItemID);
      DROP_EXT_TAB;
      
    EXCEPTION
          WHEN OTHERS THEN
          DBMS_OUTPUT.PUT_LINE('***load item error');
          DBMS_OUTPUT.PUT_LINE(SQLERRM);
          --LOAD_ITEM_CLEANUP (p_loadItemID);
          RAISE_APPLICATION_ERROR(-20001, SQLERRM);
   END;

   PROCEDURE LOAD_FROM_EXT_TAB
   AS
      l_rowCount    NUMBER;
   BEGIN

      EXECUTE IMMEDIATE g_insertStmt USING g_fileID;

      l_rowCount := SQL%ROWCOUNT;
      
      UPDATE_STATUS ('LOADED', l_rowCount, NULL);

      COMMIT;

      DBMS_OUTPUT.PUT_LINE ('inserted=' || l_rowCount);
EXCEPTION
   WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE (g_insertStmt);
           DBMS_OUTPUT.PUT_LINE('***error loading from external table');
             
           UPDATE_STATUS ('ERR_INSERT', NULL, SQLERRM);
   END;

   PROCEDURE DROP_EXT_TAB
   AS
      l_stmt   VARCHAR2 (100);
      l_cnt        number;
   BEGIN
      
      SELECT count(*) INTO l_cnt
          FROM all_tables
         WHERE table_name = g_extTableName and OWNER = g_extTableSchema; 
        IF l_cnt > 0 THEN
          EXECUTE IMMEDIATE 'drop table ' || g_extTableSchema || '.' || g_extTableName;
      END IF;         

   EXCEPTION
      WHEN OTHERS
      THEN
         DBMS_OUTPUT.PUT_LINE ('TABLE NOT EXIST!');
         RAISE;
   END;

   PROCEDURE LOAD_ITEM_CLEANUP (p_loadItemID VARCHAR2)
   AS
   BEGIN
        UPDATE DWC_LOAD_ITEM
          SET STATUS = 'CRITICAL_ERROR'
             WHERE LOAD_ITEM_CD = p_loadItemID;
        DROP_EXT_TAB;
   END;


   PROCEDURE UPDATE_STATUS (p_status         VARCHAR2,
                            p_recordCount    NUMBER,
                            p_logMessage     VARCHAR2)
   AS
   BEGIN
         DBMS_OUTPUT.PUT_LINE('***update status file_id=' || g_fileID || ' ' || 'status=' || p_status);
      CASE p_status
           WHEN 'LOADING' THEN
             UPDATE DWC_INPUT_FILE
                SET STATUS = p_status, LOAD_START_DATE = SYSDATE, log_message = p_logMessage
                  WHERE id = g_fileID;
         WHEN 'LOADED' THEN
            UPDATE DWC_INPUT_FILE
               SET STATUS = p_status, 
                      LOAD_FINISH_DATE = SYSDATE,
                   RECORD_COUNT = p_recordCount,
                   dur = (SYSDATE - LOAD_START_DATE) * 60 * 60 * 24,
                   log_message = p_logMessage
                    WHERE id = g_fileID;
         ELSE
             UPDATE DWC_INPUT_FILE SET STATUS = p_status, log_message = p_logMessage WHERE id = g_fileID;
        END  CASE;            
        COMMIT;
        RETURN;
   END;

   PROCEDURE CREATE_EXT_TAB
   AS
      l_stmt clob;
      l_cnt  number;
   BEGIN
      SELECT str_val INTO l_stmt
        FROM dwc_str_repos
       WHERE str_id = 'CREATE_EXT_' || upper(g_fileType);

        DROP_EXT_TAB;       
        g_fileName := g_extTableName; -- just set some filename

      l_stmt := REPLACE (l_stmt, '#UNL_FILE_NAME#', g_fileName);
      l_stmt := REPLACE (l_stmt, '#BAD_FILE#', replace(lower(g_extTableName), '$', ''));
      l_stmt := REPLACE (l_stmt, '#LOG_FILE#', replace(lower(g_extTableName), '$', ''));
      l_stmt := REPLACE (l_stmt, '#TABLE_NAME#', g_extTableSchema || '.' || g_extTableName);
        DBMS_OUTPUT.PUT_LINE(l_stmt);
        EXECUTE IMMEDIATE l_stmt;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
       RAISE_APPLICATION_ERROR (-20001, 'can not find create external table statement in dwc_str_repos');
   WHEN OTHERS
   THEN
       DBMS_OUTPUT.PUT_LINE('***error create external table');
      DBMS_OUTPUT.PUT_LINE(SQLERRM);
       UPDATE_STATUS ('ERR_EXT_TAB', NULL, SQLERRM);
      RAISE_APPLICATION_ERROR (-20002, 'error creating external table'); 
   END;
   
   PROCEDURE ALTER_EXT_TAB
   AS
     l_stmt varchar2(1024);
   BEGIN
       DBMS_OUTPUT.PUT_LINE('altering external table');
       l_stmt := 'alter table ' || g_extTableSchema || '.' || g_extTableName || ' LOCATION (''' || g_fileName || ''')';
       DBMS_OUTPUT.PUT_LINE(l_stmt);
       execute immediate l_stmt;
   END;                            

    PROCEDURE BUILD_INSERT_STMT AS
       l_stmt     clob;
      l_nbrTransStmt clob;
      l_start    number;
      l_len        number;
   BEGIN
        DBMS_OUTPUT.PUT_LINE('part1');
        select str_val into l_stmt from edw0.dwc_str_repos
         where str_id = 'DWB_INS_' || upper(g_fileType) || '_2';
         DBMS_OUTPUT.PUT_LINE('part2');
        select str_val into l_nbrTransStmt from edw0.dwc_str_repos
         where str_id = 'NBR_TRANS_STMT_2';
         DBMS_OUTPUT.PUT_LINE('part3');
        l_stmt := clob_replace(l_stmt, '#EXT_TAB_NAME#', g_extTableSchema || '.' || g_extTableName);
        DBMS_OUTPUT.PUT_LINE('part4');
      l_start := DBMS_LOB.INSTR(l_stmt, '#CALLED_NTWK_CD#', 1);
      DBMS_OUTPUT.PUT_LINE('part5');
      if l_start > 0 then 
      l_nbrTransStmt := clob_replace(l_nbrTransStmt, '#NBR#', 'C493');
          l_len := length('#CALLED_NTWK_CD#');
          l_stmt := DBMS_LOB.SUBSTR(l_stmt, l_start - 1, 1) || l_nbrTransStmt || DBMS_LOB.SUBSTR(l_stmt, DBMS_LOB.GETLENGTH(l_stmt) - l_start + l_len, l_start + l_len);
        end if;           
--        insert into dwc_str_repos  values('STMT_', l_stmt);
--      commit;      

DBMS_OUTPUT.PUT_LINE('part6');
      g_insertStmt := l_stmt;
                
   EXCEPTION
       WHEN NO_DATA_FOUND THEN
          RAISE_APPLICATION_ERROR (-20003, 'can not find insert statement in dwc_str_repos');
       WHEN OTHERS THEN
          DBMS_OUTPUT.PUT_LINE('error building insert statement.');
          RAISE_APPLICATION_ERROR (-20004, 'error creating insert statement');                        
   END;
   
 function CLOB_REPLACE(p_clob clob, p_what varchar2, p_with clob) 
        return clob as
    buff_size number;
   l_return clob default '';
   buff    clob;
   pos     number default 1; 
begin
    while( pos < DBMS_LOB.GETLENGTH(p_clob) )
   loop
       buff_size := 30000;
      while (DBMS_LOB.SUBSTR(p_clob, 1, pos + buff_size - 1) not in (' ', '(', ')', ',', ''''))
      loop
         buff_size := buff_size - 1;
      end loop;
      buff := SUBSTR(p_clob, pos, buff_size);
      
      buff := replace(buff, p_what, p_with);
      
      pos := pos + buff_size; 
      l_return := l_return || buff;
   end loop;   
    
    return l_return;        
end;
     

END PKG_ETL_UNL_FILES;
/
